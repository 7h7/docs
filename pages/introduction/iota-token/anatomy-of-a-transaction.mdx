import { withRouter } from 'next/router'
import WithMDX from '../../../lib/with-mdx'

import { lewi } from "../../../lib/data/team"
import {
Table,
Row,
Cell,
TypeCell,
BoldCell
} from "../../../components/api/table"

export const page = {
title: 'The Anatomy of a Transaction',
date: '19 Feburary 2018',
authors: [lewi],
editUrl: 'pages/introduction/iota-token/anatomy-of-a-transaction.mdx',
}

export default withRouter(props => WithMDX(props, page))

A transaction in IOTA consists of 2673 trytes (if encoded).
When you decode the trytes you get a transaction object
which has the following values:

<Table>
    <Row>
      <BoldCell>Field</BoldCell>
      <TypeCell>Type</TypeCell>
      <BoldCell>Description</BoldCell>
      <BoldCell>Length</BoldCell>
    </Row>
    <Row>
      <BoldCell>signatureMessageFragment</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`In case there is a spent input, 
      the signature of the private key is stored here. If no signature is 
      required, it is empty (all 9's) and can be used for storing the message 
      value when making a transfer. More to that later.`}
      </Cell>
      <BoldCell>2187</BoldCell>
    </Row>
    <Row>
      <BoldCell>address</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`In case this is an output, then this is the address of 
          the recipient. In case it is an input, then it is the 
          address of the input which is used to send the tokens 
          from (i.e. address generated from the private key)`}
      </Cell>
      <BoldCell>81</BoldCell>
    </Row>
    <Row>
      <BoldCell>value</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Transaction value`}
      </Cell>      
      <BoldCell>27</BoldCell>
    </Row>
    <Row>
      <BoldCell>obsoleteTag</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`User-defined tag (removed soon)`}
      </Cell>
      <BoldCell>27</BoldCell>
    </Row>
    <Row>
      <BoldCell>timestamp</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Timestamp (not-enforced, can be arbitrary)`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>currentIndex</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Transaction index in Bundle`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>lastIndex</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Index of last Transaction in Bundle`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>bundle</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`Hash of the current Bundle, which is used for grouping transactions
      of the bundle together. With the bundle hash you can identify
      transactions which were in the same bundle.`}
      </Cell>
      <BoldCell>81</BoldCell>
    </Row>
    <Row>
      <BoldCell>branchTransaction</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`Transaction being approved`}
      </Cell>
      <BoldCell>81</BoldCell>
    </Row>
    <Row>
      <BoldCell>trunkTransaction</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`Transaction being approved`}
      </Cell>
      <BoldCell>81</BoldCell>
    </Row>
    <Row>
      <BoldCell>attachmentTag</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`User-defined tag`}
      </Cell>
      <BoldCell>27</BoldCell>
    </Row>
    <Row>
      <BoldCell>attachmentTimestamp</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Timestamp after POW`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>attachmentTimestampLowerBound</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Lower Bound of timestamp`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>attachmentTimestampUpperBound</BoldCell>
      <TypeCell>Int</TypeCell>
      <Cell>{`Upper Bound of timestamp`}
      </Cell>
      <BoldCell>9</BoldCell>
    </Row>
    <Row>
      <BoldCell>nonce</BoldCell>
      <TypeCell>String</TypeCell>
      <Cell>{`The nonce is required for the transaction to be accepted by the
      network. It is generated by doing Proof of Work (either in IRI via
      the attachToTangle API call, or an external library).`}
      </Cell>
      <BoldCell>27</BoldCell>
    </Row>
  </Table>
